<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.0 20120330//EN" "JATS-archivearticle1.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article" xml:lang="en"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id><journal-title-group><journal-title>BMC Bioinformatics</journal-title></journal-title-group><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">16354297</article-id><article-id pub-id-type="pmc">1361783</article-id><article-id pub-id-type="publisher-id">1471-2105-6-302</article-id><article-id pub-id-type="doi">10.1186/1471-2105-6-302</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group></article-categories><title-group><article-title>Probabilistic annotation of protein sequences based on functional classifications</article-title></title-group><contrib-group><contrib contrib-type="author" id="A1"><name><surname>Levy</surname><given-names>Emmanuel D</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I3">3</xref><email>elevy@mrc-lmb.cam.ac.uk</email></contrib><contrib contrib-type="author" corresp="yes" id="A2"><name><surname>Ouzounis</surname><given-names>Christos A</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>ouzounis@ebi.ac.uk</email></contrib><contrib contrib-type="author" id="A3"><name><surname>Gilks</surname><given-names>Walter R</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>wally.gilks@mrc-bsu.cam.ac.uk</email></contrib><contrib contrib-type="author" corresp="yes" id="A4"><name><surname>Audit</surname><given-names>Benjamin</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I4">4</xref><email>Benjamin.Audit@ens-lyon.fr</email></contrib></contrib-group><aff id="I1"><label>1</label>Computational Genomics Group, The European Bioinformatics Institute, EMBL Cambridge Outstation, Cambridge CB10 1SD, UK</aff><aff id="I2"><label>2</label>Medical Research Council Biostatistics Unit, Institute of Public Health, Cambridge CB2 2SR, UK</aff><aff id="I3"><label>3</label>Computational Genomics Group, MRC Laboratory of Molecular Biology, Hills Rd, Cambridge CB2 2QH, UK</aff><aff id="I4"><label>4</label>Laboratoire Joliot-Curie and Laboratoire de Physique, CNRS UMR5672, Ecole Normale Sup&#x000e9;rieure, 46 All&#x000e9;e d'Italie, 69364 Lyon Cedex 07, France</aff><pub-date pub-type="collection"><year>2005</year></pub-date><pub-date pub-type="epub"><day>14</day><month>12</month><year>2005</year></pub-date><volume>6</volume><fpage>302</fpage><lpage>302</lpage><history><date date-type="received"><day>20</day><month>5</month><year>2005</year></date><date date-type="accepted"><day>14</day><month>12</month><year>2005</year></date></history><permissions><copyright-statement>Copyright &#x000a9;2005 Levy et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2005</copyright-year><copyright-holder>Levy et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><license-p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p></license></permissions><self-uri xlink:href="http://www.biomedcentral.com/1471-2105/6/302"/><abstract><sec><title>Background</title><p>One of the most evident achievements of bioinformatics is the development of methods that transfer biological knowledge from characterised proteins to uncharacterised sequences. This mode of protein function assignment is mostly based on the detection of sequence similarity and the premise that functional properties are conserved during evolution. Most automatic approaches developed to date rely on the identification of clusters of homologous proteins and the mapping of new proteins onto these clusters, which are expected to share functional characteristics.</p></sec><sec><title>Results</title><p>Here, we inverse the logic of this process, by considering the mapping of sequences directly to a functional classification instead of mapping functions to a sequence clustering. In this mode, the starting point is a database of labelled proteins according to a functional classification scheme, and the subsequent use of sequence similarity allows defining the membership of new proteins to these functional classes. In this framework, we define the Correspondence Indicators as measures of relationship between sequence and function and further formulate two Bayesian approaches to estimate the probability for a sequence of unknown function to belong to a functional class. This approach allows the parametrisation of different sequence search strategies and provides a direct measure of annotation error rates. We validate this approach with a database of enzymes labelled by their corresponding four-digit EC numbers and analyse specific cases.</p></sec><sec><title>Conclusion</title><p>The performance of this method is significantly higher than the simple strategy consisting in transferring the annotation from the highest scoring BLAST match and is expected to find applications in automated functional annotation pipelines.</p></sec></abstract></article-meta></front><body><sec><title>Background</title><p>The gap between the growth rate of biological sequence databases and the capability to characterise experimentally the roles and functions associated with these new sequences is constantly increasing [<xref ref-type="bibr" rid="B1">1</xref>]. This results in an accumulation of raw data that can lead to an increase in our biological knowledge only if computational characterisation tools are developed. We focus here on the annotation of protein function. A generic approach to this problem consists of transferring the annotation from sequences of known function to uncharacterised proteins [<xref ref-type="bibr" rid="B2">2</xref>]. The transfer mechanism might be subdivided in two steps: (i) to establish the list of known proteins with significant sequence similarity to the uncharacterised sequence; (ii) to select the known sequence(s) from which the annotation is transferred [<xref ref-type="bibr" rid="B3">3</xref>]. The first step is usually performed with sequence alignment tools such as FASTA [<xref ref-type="bibr" rid="B4">4</xref>] or BLAST [<xref ref-type="bibr" rid="B5">5</xref>]. When sensitivity is critical, alternative tools such as PSI-BLAST [<xref ref-type="bibr" rid="B6">6</xref>] and hidden Markov models [<xref ref-type="bibr" rid="B7">7</xref>] can be used. Finding homologous proteins can also be accomplished using alignment-independent sequence comparison tools, which have been developed to overcome the limitation arising from the assumption of contiguity between homologous segments [<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B9">9</xref>]. Then, the challenge is the selection of true homologues from the list of similar sequences. Most of the above tools provide a score measuring the degree of similarity between the sequences compared. A simple criterion to single out a homologue is to choose the most similar sequence i.e. the highest scoring sequence. More elaborate methods have been designed to enhance the precision and reliability of the annotation process. These rely on the combination of the annotations of more than one homologue [<xref ref-type="bibr" rid="B10">10</xref>-<xref ref-type="bibr" rid="B13">13</xref>] or, for example, on semantic analyses of annotation lines [<xref ref-type="bibr" rid="B14">14</xref>].</p><p>This type of annotation process relies on the assumption of a strong relationship between protein sequence and function. This hypothesis is generally fair [<xref ref-type="bibr" rid="B15">15</xref>] even though many studies have demonstrated the existence of counter-examples that can lead to annotation errors [<xref ref-type="bibr" rid="B16">16</xref>-<xref ref-type="bibr" rid="B19">19</xref>]. Two major origins of errors can be distinguished: (i) the short listed homologous protein(s) have a different function from the sequence to be annotated (failure of the sequence-function paradigm or error in the homology search); (ii) the transferred annotations were themselves not correct (transfer of database errors). The second type of errors along with the iterative usage of annotation transfer gives rise to the specific problem of error propagation when newly annotated sequences are included in the reference database used for the homology search. Recent studies have shown that dramatic consequences on the reliability of database annotations are likely to arise from this process [<xref ref-type="bibr" rid="B20">20</xref>]. In order to improve our control on these two types of errors, it would be very useful to associate a measure of reliability to the annotations obtained. In this way, we might limit the introduction of new errors and limit their propagation by not admitting the transfer of the less reliable annotations.</p><p>In this work, we address this issue by developing a probabilistic framework to the homology-based annotation process. Our approach relies on the usage of a reference dataset where protein sequences are classified into functional classes. Here, an annotation is a membership to a functional class, thus, function sharing is evident. The possibility for a protein to perform a particular function is then assessed based on its similarity relationships with all protein sequences known to perform this function; it enables for instance to take into consideration both the presence and the absence of similarity. This possibility is used during the training step of machine-learning approaches for sequence annotation, which relies on the availability of a classified reference dataset [<xref ref-type="bibr" rid="B21">21</xref>-<xref ref-type="bibr" rid="B23">23</xref>]. Note that most other methods proposed to date map function to proteins by first "clustering" proteins based on sequence similarities and second combining the functional description of the characterised proteins to propose a description for the uncharacterised sequences. The present approach inverts this process by mapping sequences to a functional classification instead of mapping functions to a sequence clustering. Following this idea, we propose a method to build <italic>correspondence indicators </italic>(CIs) between sequences and functional classes. Then, we explore two Bayesian annotation frameworks based on the comparison of the CIs of a sequence of unknown function with the observed CIs for the reference protein sequences. This framework provides probabilities for a sequence to belong to the different functional classes. We advocate the use of these probabilities as a direct measure of the reliability of annotations.</p><p>To validate both probabilistic methods for automatic annotation, we applied them to the well-established classification of enzymes. Our results show that both methods allow distinguishing proteins whose annotation is reliable from the others. At the highest level of reliability, the two methods predict the four EC digits with a very low error rate (~0.002) for 90.6% and 96.0% of enzymes respectively. We compared these results with the simple strategy consisting in transferring the EC number of the BLAST best hit. Our best method has an error rate half that of the best-hit strategy at the same coverage level.</p></sec><sec sec-type="results"><title>Results</title><sec><title>Defining correspondence indicators</title><p>Given a functional classification, annotating a new protein consists in establishing to which functional class or classes it belongs. To approach the problem we defined a <italic>Correspondence Indicator </italic>(CI) between the new protein and each of the functional classes, and second, formulated a classification scheme based on these indicators. This section is devoted to the first point, whereas the second one will be treated in the following section.</p><p>Using the bit-scores of sequence alignments (See Methods), we can imagine many different scoring strategies to measure this correspondence. For instance, we could use the number of hits (with a bit-score above a given threshold), or the best bit-score between the new protein and the functional class members. Alternatively, we might choose to compromise between the two above options by taking the sum of the bit-scores between the new protein and the class members.</p><p>Here, we propose a measure that unifies these three strategies. Let &#x003a9;<sub>1</sub>, ..., &#x003a9;<sub>n </sub>symbolise the set of <italic>n </italic>functional classes with respective sizes <italic>N</italic><sub>1</sub>, ..., <italic>N</italic><sub>n</sub>. We denote <italic>S</italic><sub><italic>c,d </italic></sub>the BLAST bit-score between two proteins <italic>c </italic>and <italic>d</italic>. Then, we define the CI <inline-formula><mml:math id="M1" name="1471-2105-6-302-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) parameterised by &#x003b1;&#x02208;[0,+&#x0221e;), between a new protein <italic>c </italic>and the class &#x003a9;<sub>j </sub>as follows:</p><p><inline-formula><mml:math id="M2" name="1471-2105-6-302-i2" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mstyle displaystyle="true"><mml:munder><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>d</mml:mi><mml:mo>&#x02208;</mml:mo><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:munder><mml:mrow><mml:msubsup><mml:mi>S</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:msubsup></mml:mrow></mml:mstyle><mml:mo>,</mml:mo><mml:mtext>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula></p><p>where the sum is taken over bit-scores <italic>S</italic><sub><italic>c,d </italic></sub>greater than a given threshold S<sub>0</sub>, for c&#x02260;d. <inline-formula><mml:math id="M3" name="1471-2105-6-302-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) measures the strength of the homology relationship between the new protein <italic>c </italic>and the family &#x003a9;<sub>j </sub>as the sum of the pairwise bit-scores to the power &#x003b1; between <italic>c </italic>and all class members. The possibility to choose the parameter &#x003b1; allows modulating the relative weight of each hit with a class: the relative weight of hits with larger bit-scores increases with &#x003b1;. Using &#x003b1; = 0, all the hits have the same weight and <inline-formula><mml:math id="M4" name="1471-2105-6-302-i3" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) is simply the "number of hits" of <italic>c </italic>with &#x003a9;<sub>j</sub>. When &#x003b1; = 1, the weight of each hit is its bit-score and <inline-formula><mml:math id="M5" name="1471-2105-6-302-i4" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) is the "sum of the bit-scores". Finally, as &#x003b1;&#x02192;&#x0221e; only the hit with the largest bit-score counts and <inline-formula><mml:math id="M6" name="1471-2105-6-302-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo>&#x02192;</mml:mo><mml:mi>&#x0221e;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) reduces to <inline-formula><mml:math id="M7" name="1471-2105-6-302-i6" overflow="scroll"><mml:semantics><mml:mrow><mml:msup><mml:mrow><mml:munder><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>d</mml:mtext><mml:mtext>&#x02009;</mml:mtext><mml:mtext>&#x02009;</mml:mtext><mml:mo>&#x02208;</mml:mo><mml:mtext>&#x02009;</mml:mtext><mml:mtext>&#x02009;</mml:mtext><mml:mi>j</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula>, which is equivalent to the "best bit-score" scoring strategy. (For large value of &#x003b1;, it can be convenient to simply define <inline-formula><mml:math id="M8" name="1471-2105-6-302-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo>&#x02192;</mml:mo><mml:mi>&#x0221e;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) as the best bit-score with class &#x003a9;<sub>j</sub>: <inline-formula><mml:math id="M9" name="1471-2105-6-302-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo>&#x02192;</mml:mo><mml:mi>&#x0221e;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) = <inline-formula><mml:math id="M10" name="1471-2105-6-302-i7" overflow="scroll"><mml:semantics><mml:mrow><mml:munder><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x02061;</mml:mo></mml:mrow><mml:mrow><mml:mtext>d</mml:mtext><mml:mtext>&#x02009;</mml:mtext><mml:mtext>&#x02009;</mml:mtext><mml:mo>&#x02208;</mml:mo><mml:mtext>&#x02009;</mml:mtext><mml:mtext>&#x02009;</mml:mtext><mml:mi>j</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>c</mml:mi><mml:mo>,</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:semantics></mml:math></inline-formula>). Thus, the choice of &#x003b1; enables a continuous variation between the strategies where only the number of hits or only the bit-score of the best hit counts. To our knowledge, such a parametric approach to sequence search metrics has not been proposed previously. Note that a more sophisticated combination of the CIs obtained for different &#x003b1; values could take advantage of various aspect of information captured by each of these &#x003b1; values.</p></sec><sec><title>Different strategies of annotation</title><sec><title>Best correspondence indicator strategy</title><p>Given a fixed value for &#x003b1;, the simplest classification scheme is to assign the new protein <italic>c </italic>to the class <inline-formula><mml:math id="M11" name="1471-2105-6-302-i8" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mrow><mml:msub><mml:mi>j</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> that maximises the CI. For &#x003b1; = 0, it is the functional class with the greatest number of hits with <italic>c</italic>. When &#x003b1;&#x02192;&#x0221e;, this amounts to the class containing the sequence closest to <italic>c</italic>: a simple "best hit" strategy of annotation. Note that different values of &#x003b1; may result in a different classification of <italic>c</italic>.</p></sec><sec><title>Estimating the probability for a protein sequence to belong to a functional class: an univariate Bayesian approach</title><p>A limitation to the "best CI" strategy of annotation is the lack of a reliability assessment for the functional assignments. To overcome this limitation, we propose to estimate, independently for each of the functional classes, the probability <italic>P</italic>(c &#x02208; &#x003a9;<sub>j </sub>| <inline-formula><mml:math id="M12" name="1471-2105-6-302-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>)) for a protein <italic>c </italic>drawn at random, to belong to class &#x003a9;<sub>j </sub>given <inline-formula><mml:math id="M13" name="1471-2105-6-302-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) i.e. we estimate probabilities knowing one variable (indicator) only. Using Bayes theorem, we can show [See <xref ref-type="supplementary-material" rid="S1">Additional file 1</xref>, Section S2] that this conditional probability can be estimated by:</p><p><inline-formula><mml:math id="M14" name="1471-2105-6-302-i9" overflow="scroll"><mml:semantics><mml:mrow><mml:mover accent="true"><mml:mi>P</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo>&#x02208;</mml:mo><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:msubsup><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x000b1;</mml:mo><mml:mi>&#x003bb;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x000b1;</mml:mo><mml:mi>&#x003bb;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo><mml:mtext>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula></p><p>where <inline-formula><mml:math id="M15" name="1471-2105-6-302-i10" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x000b1;</mml:mo><mml:mi>&#x003bb;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> and <inline-formula><mml:math id="M16" name="1471-2105-6-302-i11" overflow="scroll"><mml:semantics><mml:mrow><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x000b1;</mml:mo><mml:mi>&#x003bb;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula> are respectively, the number of proteins truly belonging to class &#x003a9;<sub>j </sub>and the number of proteins from the entire dataset, whose correspondence indicator with class &#x003a9;<sub>j </sub>is comprised in [(<inline-formula><mml:math id="M17" name="1471-2105-6-302-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) - &#x003bb;), (<inline-formula><mml:math id="M18" name="1471-2105-6-302-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) + &#x003bb;)] . This mechanism is illustrated in <xref ref-type="supplementary-material" rid="S1">Additional file 1</xref>, Figures S1(a). &#x003bb; is fixed for the annotation of each new protein such that the total number of sampled proteins <italic>N </italic>(<inline-formula><mml:math id="M19" name="1471-2105-6-302-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>d</italic>) &#x000b1; &#x003bb;) is always equal to 10. This can be viewed as an adaptive smoothing of the data: &#x003bb; is increased until the interval [(<inline-formula><mml:math id="M20" name="1471-2105-6-302-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) - &#x003bb;), (<inline-formula><mml:math id="M21" name="1471-2105-6-302-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) + &#x003bb;)] contains a predetermined quantity of information (10 proteins).</p></sec><sec><title>Determining the most likely functional class of a protein sequence: a multivariate Bayesian method of annotation</title><p>In the previous approach, we assessed the membership of a new protein to a functional class using only the CI with this class. Because this process is performed independently for each class, it allows several probabilities to be close to 1. In such circumstances functional assignment is ambiguous. To improve the control on these cases, we propose to estimate the probability <italic>P</italic>(<italic>c</italic>&#x02208;&#x003a9;<sub>j</sub>|{<inline-formula><mml:math id="M22" name="1471-2105-6-302-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) ... <inline-formula><mml:math id="M23" name="1471-2105-6-302-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>)}) of a new protein <italic>c </italic>to belong to &#x003a9;<sub>j </sub>knowing the set {<inline-formula><mml:math id="M24" name="1471-2105-6-302-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) ... <inline-formula><mml:math id="M25" name="1471-2105-6-302-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>)} of its CIs with all the functional classes i.e. we estimate probabilities based on multiple variables (indicators). Using Bayes theorem, we can show [See <xref ref-type="supplementary-material" rid="S1">Additional file 1</xref>, Section S3] that:</p><p><inline-formula><mml:math id="M26" name="1471-2105-6-302-i14" overflow="scroll"><mml:semantics><mml:mrow><mml:mover accent="true"><mml:mi>P</mml:mi><mml:mo>^</mml:mo></mml:mover><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo>&#x02208;</mml:mo><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>|</mml:mo><mml:mo>{</mml:mo><mml:msubsup><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02026;</mml:mo><mml:msubsup><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>{</mml:mo><mml:msubsup><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02026;</mml:mo><mml:msubsup><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mtext>r</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>B</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo>{</mml:mo><mml:msubsup><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02026;</mml:mo><mml:msubsup><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>c</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo><mml:mo>,</mml:mo><mml:mtext>r</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>.</mml:mo><mml:mtext>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>3</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:semantics></mml:math></inline-formula></p><p>Estimating this probability amounts to consider the <italic>n</italic>-dimensional space of CIs and to look in that space what is the functional composition of the proteins that have their position within the sphere B ({<inline-formula><mml:math id="M27" name="1471-2105-6-302-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) ... <inline-formula><mml:math id="M28" name="1471-2105-6-302-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>)}, <italic>r</italic>) of radius <italic>r</italic>, centred at {<inline-formula><mml:math id="M29" name="1471-2105-6-302-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) ... <inline-formula><mml:math id="M30" name="1471-2105-6-302-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>)}. In other words, we count the number of proteins within the sphere <italic>B </italic>({<inline-formula><mml:math id="M31" name="1471-2105-6-302-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) ... <inline-formula><mml:math id="M32" name="1471-2105-6-302-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>)}, <italic>r</italic>) that truly belong to class &#x003a9;<sub>j</sub>. The ratio between this number and the total number of proteins in the sphere is <inline-formula><mml:math id="M33" name="1471-2105-6-302-i15" overflow="scroll"><mml:semantics><mml:mover accent="true"><mml:mi>P</mml:mi><mml:mo>^</mml:mo></mml:mover></mml:semantics></mml:math></inline-formula> (<italic>c </italic>&#x02208; &#x003a9;<sub><italic>j </italic></sub>| {<inline-formula><mml:math id="M34" name="1471-2105-6-302-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) ... <inline-formula><mml:math id="M35" name="1471-2105-6-302-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>)}). This mechanism is illustrated in <xref ref-type="supplementary-material" rid="S1">Additional file 1</xref>, Figure S1(b).</p><p>As previously for &#x003bb;, <italic>r </italic>is determined for each protein such that the total number of proteins sampled <italic>N</italic>(<italic>B</italic>({<inline-formula><mml:math id="M36" name="1471-2105-6-302-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) ... <inline-formula><mml:math id="M37" name="1471-2105-6-302-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>)}, r)) is always 10. Note that this method amounts to find the 10 closest proteins from the reference dataset to the point {<inline-formula><mml:math id="M38" name="1471-2105-6-302-i12" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) ... <inline-formula><mml:math id="M39" name="1471-2105-6-302-i13" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>)} in the CI space. The logic behind this adaptive methodology is that the local density of proteins in the CI space can be highly variable depending on the average level of homology between proteins in each functional class. Hence, using constant value for &#x003bb; and <italic>r </italic>is not adequate. In this framework, it does not make sense to attempt classifying proteins into classes with less than 10 members. The particular choice of 10 corresponds to a trade off between precision (the higher the number of proteins in the neighbourhood, the higher the precision of probability calculations; see the caption from Table <xref ref-type="table" rid="T1">1</xref>) and coverage i.e. the number of EC classes considered (see Methods).</p><table-wrap id="T1" position="float"><label>Table 1</label><caption><p>Performance of the Univariate Bayesian annotation approach. Re-annotation of the filtered ENZYME database with the univariate Bayesian approach. Since we systematically sample 10 enzymes to calculate the probabilities for a protein to belong to each functional class (See Different strategies of annotation), probabilities can only take one of the following eleven values: 0, 0.1, ..., 0.9, 1. We report for each assignment probability level and globally the number of correct annotations, the number of annotation errors and the corresponding error rate and coverage of the database.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" colspan="13">Univariate Bayesian approach</th></tr></thead><tbody><tr><td align="left"><bold>Assignment probability</bold></td><td align="center"><bold>0</bold></td><td align="center"><bold>0.1</bold></td><td align="center"><bold>0.2</bold></td><td align="center"><bold>0.3</bold></td><td align="center"><bold>0.4</bold></td><td align="center"><bold>0.5</bold></td><td align="center"><bold>0.6</bold></td><td align="center"><bold>0.7</bold></td><td align="center"><bold>0.8</bold></td><td align="center"><bold>0.9</bold></td><td align="center"><bold>1</bold></td><td align="center"><bold>TOT</bold></td></tr><tr><td align="left"><bold>Correct annotations</bold></td><td align="center">84</td><td align="center">109</td><td align="center">103</td><td align="center">99</td><td align="center">119</td><td align="center">177</td><td align="center">252</td><td align="center">302</td><td align="center">437</td><td align="center">726</td><td align="center"><bold>25387</bold></td><td align="center">27795</td></tr><tr><td align="left"><bold>Annotation errors</bold></td><td align="center">27</td><td align="center">15</td><td align="center">5</td><td align="center">11</td><td align="center">13</td><td align="center">23</td><td align="center">41</td><td align="center">29</td><td align="center">31</td><td align="center">45</td><td align="center"><bold>53</bold></td><td align="center">293</td></tr><tr><td align="left"><bold>Error rate (%)</bold></td><td align="center">24.3</td><td align="center">12.1</td><td align="center">4.6</td><td align="center">10.0</td><td align="center">9.8</td><td align="center">11.5</td><td align="center">14.0</td><td align="center">8.8</td><td align="center">6.6</td><td align="center">5.8</td><td align="center"><bold>0.21</bold></td><td align="center">1.04</td></tr><tr><td align="left"><bold>Coverage (%)</bold></td><td align="center">0.4</td><td align="center">0.4</td><td align="center">0.4</td><td align="center">0.4</td><td align="center">0.5</td><td align="center">0.7</td><td align="center">1.0</td><td align="center">1.2</td><td align="center">1.7</td><td align="center">2.7</td><td align="center"><bold>90.6</bold></td><td align="center">100.0</td></tr></tbody></table></table-wrap></sec></sec><sec><title>Determining the optimal correspondence indicator</title><p>The freedom of choice of the parameter &#x003b1; in the CI <inline-formula><mml:math id="M40" name="1471-2105-6-302-i1" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) (Eq.(1)) allows us to combine in different ways the bit-scores of the alignments of protein <italic>c </italic>with the proteins of the class &#x003a9;<sub>j</sub>. The choice of &#x003b1; enables a continuous variation between the strategies where only the number of hits above the threshold S<sub>0 </sub>(&#x003b1; = 0) or only the bit-score of the best hit (&#x003b1;&#x02192;&#x0221e;) counts (See Defining correspondence indicators). To optimise the parameters &#x003b1; and S<sub>0</sub>, we re-annotated each enzyme (See Methods) using the best CI strategy (See Different strategies of annotation) with different combinations of their values. In Figure <xref ref-type="fig" rid="F1">1</xref>, we report the number of annotation errors E(&#x003b1;,S<sub>0</sub>) for each combination of these parameters. At a fixed value of S<sub>0</sub>, we observe that the higher &#x003b1;, the lower the number of errors. Moreover, the difference between the number of errors at &#x003b1; = 0 and at &#x003b1; = 10 soars for small S<sub>0 </sub>values (20 folds at S<sub>0 </sub>= 45: E(0,45) = 2156 and E(10,45) = 122). This effect is due to the poor specificity of alignments having a small bit-score. With no cut-off (S<sub>0 </sub>= 0), all sequences hit one another and thus, for &#x003b1; = 0 all the functional assignments are made to the largest class. This illustrates that the choice of the &#x003b1; value can be critical, and that for small &#x003b1; values, the sensitivity to S<sub>0 </sub>is higher. At a fixed value of &#x003b1;, by increasing the cut-off S<sub>0 </sub>we minimise the number of errors as expected, but simultaneously the coverage of annotated proteins drops significantly (Fig. <xref ref-type="fig" rid="F2">2</xref>). Indeed, a protein cannot be annotated if all its hits have a bit-score below the cut-off. This shows that if we do not want to lose too much coverage, there is very little latitude on S<sub>0</sub>.</p><fig id="F1" position="float"><label>Figure 1</label><caption><p><bold>Number of re-annotation errors</bold>. Number of annotation errors E(&#x003b1;,S<sub>0</sub>) made during the re-annotation of the 28088 enzymes of the filtered ENZYME database (See Methods) using the best CI strategy (See Different strategies of annotation) as a function of the parameter &#x003b1; and cut-off S<sub>0 </sub>(Eq. (1)).</p></caption><graphic xlink:href="1471-2105-6-302-1"/></fig><fig id="F2" position="float"><label>Figure 2</label><caption><p><bold>Re-annotation error rate</bold>. Rate of annotation error as a function of the coverage for the re-annotation of the 28088 enzymes of the filtered ENZYME database (See Methods). The full line corresponds to the <italic>best-hit strategy </italic>(See Determining the optimal correspondence indicator); the curve was obtained by performing the re-annotation for different values of the threshold S<sub>0 </sub>between 45 (100% coverage by definition of the filtered ENZYME database) and 841. (&#x02207;,&#x02206;) correspond to the univariate and multivariate Bayesian methods at the highest confidence level (P = 1, Tables 1 and 2). (&#x025ca;) corresponds to the "clear cases" identified by the univariate Bayesian method (P = 1 and second highest probability equals to 0; see Re-annotation with the univariate Bayesian approach).</p></caption><graphic xlink:href="1471-2105-6-302-2"/></fig><p>By minimising the number of errors to determine the optimal value for &#x003b1;, we conclude that the best bit-score strategy (&#x003b1;&#x02192;&#x0221e;) is the one which best describes the relation between an enzyme and its functional class. Moreover, given the weak sensitivity to S<sub>0 </sub>for &#x003b1;&#x02192;&#x0221e;, we choose the smallest value S<sub>0 </sub>= 45 for the threshold in order to maximise the coverage. Then, from now on, the only CI we will be using is <inline-formula><mml:math id="M41" name="1471-2105-6-302-i5" overflow="scroll"><mml:semantics><mml:mrow><mml:msubsup><mml:mi>Y</mml:mi><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo>&#x02192;</mml:mo><mml:mi>&#x0221e;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:msubsup></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) for S<sub>0 </sub>= 45, denoted <inline-formula><mml:math id="M42" name="1471-2105-6-302-i16" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>). The best CI strategy with &#x003b1;&#x02192;&#x0221e; reduces to a BLAST <italic>best-hit strategy </italic>(See Different strategies of annotation). Its performance depends only on the threshold S<sub>0 </sub>that also directly controls the coverage (Fig. <xref ref-type="fig" rid="F2">2</xref>). It will serve as a reference to compare to the results obtained with the two probabilistic approaches. In this way, given the same input (BLAST pairwise bit-scores), we will assess the improvement in annotation quality obtained by an efficient usage of a functional classification on the reference dataset. Recently developed database search methods exploit sequence profiles and often outperform BLAST in terms of sensitivity for the detection of remote homologies. However, this increase in sensitivity usually comes at the expense of specificity, which is the most important feature in the present set up. Indeed, most enzymes have easily detectable homologies with sequences from their EC class.</p></sec><sec><title>Re-annotation with the univariate Bayesian approach</title><p>The univariate Bayesian approach allows estimating the probabilities for an enzyme to belong to a particular EC class &#x003a9;<sub>j</sub>, given only <inline-formula><mml:math id="M43" name="1471-2105-6-302-i16" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) (the maximum bit-score with this class). To annotate an enzyme using this method, we derive probability estimates for its membership in each functional class (Eq.(2)) and assign it to the class for which the probability is largest. We re-annotated all enzymes of the reference dataset <italic>via </italic>this approach, using the leave-one-out method (See Methods). The results of this re-annotation are presented Table <xref ref-type="table" rid="T1">1</xref>. There is a total annotation error rate r = 0.010 (293 errors), which is more than twice as large as for the re-annotation of the reference dataset by the best-hit strategy (Fig. <xref ref-type="fig" rid="F2">2</xref>: r = 0.0045, 126 errors). However, we can take advantage of the assignment probabilities that do not exist for the best-hit strategy and that are a direct measure of the confidence we have in an assignment. Considering the large proportion of proteins (90.6%) that are annotated with the highest confidence (assignment probability of 1), we notice that r = 0.0021 (53 errors), two fold smaller than for the best-hit strategy. The reduction of the error rate remains very significant even if we take into account the coverage of annotation: at the same coverage, the best-hit strategy leads to a rate of error of 0.0034 which is 1.5 larger (Fig. <xref ref-type="fig" rid="F2">2</xref>). To achieve the same rate of error with the best-hit strategy the coverage drops to 54% (Fig. <xref ref-type="fig" rid="F2">2</xref>). Interestingly, for assignment probabilities smaller than 1, the error rate dramatically increases (r &#x0003e; 0.05). These results demonstrate that flagging annotations with the assignment probabilities allows us to filter out likely errors. Finally, we note in Table <xref ref-type="table" rid="T1">1</xref> that 84 proteins are reported to be correctly annotated with an assignment probability equals to 0. These proteins only hit their true class and so, can be assigned only to it. However, because their CI with their class falls in a range of values with only protein from other classes, the assignment probability is equal to zero (Eq.(2)).</p><p>In this mode of automatic annotation, the probabilities of membership of a protein to each functional class are estimated independently, allowing for two or more probabilities to be significant e.g. 1 and 0.8. In principle, this property permits to assign a protein to more than one functional class. Nevertheless, if proteins can belong to one functional class only, as for the set of enzymes considered here (See Methods), these situations correspond to ambiguous cases that are more likely to lead to annotation errors than instances where proteins have only one significant probability. Indeed, out of the 25387 enzymes annotated with an assignment probability of 1 (Table <xref ref-type="table" rid="T1">1</xref>), 23655 have their second highest probability equal to 0 (data not shown). For these "clear cases", the error rate is significantly reduced to r = 0.0009 (21 errors) which is 3 times smaller than the error rate for the maximum bit-score strategy at the same annotation coverage (Fig. <xref ref-type="fig" rid="F2">2</xref>; r = 0.0031 at 84% coverage). This result strongly suggests that taking into account simultaneously the CIs with all functional classes can lead to significant improvement in the annotation process. This approach is investigated in the next section.</p></sec><sec><title>Re-annotation with the multivariate Bayesian method</title><p>We now explore a multivariate Bayesian method taking into account all CIs concurrently. More precisely, each protein is mapped to a point in an <italic>n</italic>-dimensional space where each dimension corresponds to one of the <italic>n </italic>possible functional classes. In this space, the coordinates of a protein are the CIs <inline-formula><mml:math id="M44" name="1471-2105-6-302-i16" overflow="scroll"><mml:semantics><mml:mrow><mml:msub><mml:mtext>Y</mml:mtext><mml:mrow><mml:msub><mml:mi>&#x003a9;</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:semantics></mml:math></inline-formula> (<italic>c</italic>) (maximum bit-score) with each family. The probabilities for a protein to belong to each functional class are estimated simultaneously according to the functional class of the 10 proteins of the reference dataset closest to the unclassified protein in this space (See Different strategies of annotation and <xref ref-type="supplementary-material" rid="S1">Additional file 1</xref>, Fig. S1(b)). Note that compared to the univariate Bayesian approach, protein neighbourhood is determined globally, just once. As a result, the sum of all the probabilities is always 1; there cannot be more than one significant class membership probability (P~1) per protein.</p><p>We re-annotated all enzymes of the reference dataset <italic>via </italic>this method (See Methods, Table <xref ref-type="table" rid="T2">2</xref>). Compared with the univariate approach, we note a decrease of the global error rate (r = 0.0079 vs. 0.010). At the highest annotation confidence (assignment probability of 1), we observe a significant increase of the annotation coverage (96.0% vs. 90.6%) concomitant with a stable error rate (r = 0.0020 and 53 errors vs. r = 0.0021 and 53 errors). The error rate at the highest confidence level is half that of the best-hit strategy for the same coverage. We observe that to achieve a similar error rate the coverage of the best-hit strategy would dramatically drop to 51% (Fig. <xref ref-type="fig" rid="F2">2</xref>). Interestingly, the assignment probabilities closely match the empirical error rates. For instance, for the set of enzymes annotated with an assignment probability of 0.7, we measure an error rate of 0.242 (&#x02248;1-0.7).</p><table-wrap id="T2" position="float"><label>Table 2</label><caption><p>Performance of the Multivariate Bayesian annotation method. Re-annotation of the filtered ENZYME database with the multivariate Bayesian method. Since we systematically sample 10 enzymes to calculate the probabilities for a protein to belong to each functional class (See Different strategies of annotation), probabilities can only take one of the following eleven values: 0, 0.1, ..., 0.9, 1. We report for each assignment probability level and globally the number of correct annotations, the number of annotation errors and the corresponding error rate and coverage of the database.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" colspan="13">Multivariate Bayesian method</th></tr></thead><tbody><tr><td align="left"><bold>Assignment probability</bold></td><td align="center"><bold>0</bold></td><td align="center"><bold>0.1</bold></td><td align="center"><bold>0.2</bold></td><td align="center"><bold>0.3</bold></td><td align="center"><bold>0.4</bold></td><td align="center"><bold>0.5</bold></td><td align="center"><bold>0.6</bold></td><td align="center"><bold>0.7</bold></td><td align="center"><bold>0.8</bold></td><td align="center"><bold>0.9</bold></td><td align="center"><bold>1</bold></td><td align="center"><bold>TOT</bold></td></tr><tr><td align="left"><bold>Correct annotations</bold></td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">9</td><td align="center">35</td><td align="center">109</td><td align="center">116</td><td align="center">188</td><td align="center">511</td><td align="center"><bold>26898</bold></td><td align="center">27866</td></tr><tr><td align="left"><bold>Annotation errors</bold></td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">5</td><td align="center">10</td><td align="center">37</td><td align="center">34</td><td align="center">37</td><td align="center">29</td><td align="center">17</td><td align="center"><bold>53</bold></td><td align="center">222</td></tr><tr><td align="left"><bold>Error rate (%)</bold></td><td align="center">-</td><td align="center">-</td><td align="center">-</td><td align="center">100.0</td><td align="center">52.6</td><td align="center">51.4</td><td align="center">23.4</td><td align="center">24.2</td><td align="center">13.4</td><td align="center">3.2</td><td align="center"><bold>0.20</bold></td><td align="center">0.79</td></tr><tr><td align="left"><bold>Coverage (%)</bold></td><td align="center">0.0</td><td align="center">0.0</td><td align="center">0.0</td><td align="center">0.0</td><td align="center">0.1</td><td align="center">0.3</td><td align="center">0.5</td><td align="center">0.5</td><td align="center">0.8</td><td align="center">1.9</td><td align="center"><bold>96.0</bold></td><td align="center">100</td></tr></tbody></table></table-wrap></sec><sec><title>Comparing the two Bayesian annotation strategies</title><p>The two Bayesian methodologies differ significantly on the coverage of the database of enzymes annotated at the maximum level of reliability (probability 1): 90.6% (25440/28088) for the univariate approach in contrast with 96.0% (26951/28088) for the multivariate method. This increase of coverage actually associated with a constant number of errors (53) corresponds to 1511 more correct annotations in favour of the multivariate method (Tables <xref ref-type="table" rid="T1">1</xref> and <xref ref-type="table" rid="T2">2</xref>). This is due to the fact that the multivariate Bayesian method regards a protein sequence as a single point in the CI space while the univariate Bayesian approach considers the orthogonal projection on each CI axis separately. Figures <xref ref-type="fig" rid="F3">3(a)</xref> and <xref ref-type="fig" rid="F3">3(b)</xref> propose two examples to illustrate the consequences of this difference.</p><fig id="F3" position="float"><label>Figure 3</label><caption><p><bold>Examples of topology in the CI space. </bold>In 4 cases where there is a strong cross similarity between sequences belonging to two different EC classes, we plot for each protein of these classes a point whose 2 coordinates are the CIs of its sequence with the two functional classes (BLAST best-hit with the corresponding EC class). (a): EC 2.3.1.61 (black circles) and EC 2.3.1.12 (grey triangles); crosses on top and at right correspond to the projection on the CI axes; the dotted circle (boxes on top and to the right) marks the limit of the sampling regions used to annotate O31550 with the multivariate (univariate) Bayesian method [See <xref ref-type="supplementary-material" rid="S1">Additional file 1</xref>, Fig. S1]. (b): EC 1.6.5.3 (black triangles) and EC 1.6.99.5 (grey circles). (c): EC 1.2.1.59 (black triangles) and EC 1.2.1.12 (grey circles). (d): EC 1.4.1.3 (black triangles) and EC 1.4.1.4 (grey circles); the arrow shows the change of position of protein P94598 in the CI space when the annotation of P95544 is corrected from EC 1.4.1.4 to EC 1.4.1.3 (See Analysing the origins of annotation errors).</p></caption><graphic xlink:href="1471-2105-6-302-3"/></fig><sec><title>Exploring the CI space for EC classes 2.3.1.61 (Dihydrolipoamide S-succinyltransferase) and 2.3.1.12 (Dihydrolipoamide S-acetyltransferase)</title><p>Focusing on protein O31550 [Swiss-Prot:<ext-link ext-link-type="sprot" xlink:href="O31550">O31550</ext-link>] from EC 2.3.1.12, we note Figure <xref ref-type="fig" rid="F3">3(a)</xref> that its CIs (best bit-scores) with both EC classes are similar (231 on the Y-coordinate with EC2.3.1.12 and 225 on the X-coordinate with EC 2.3.1.61). To calculate the probabilities to belong to each EC classes with the multivariate Bayesian method, we look at the functional distribution of the proteins closest to O31550 in the CI space (See Different strategies of annotation, Eq.(3)). This process is represented by the dotted circle in Figure <xref ref-type="fig" rid="F3">3(a)</xref>; it leads to <italic>P</italic><sub>2.3.1.12 </sub>= 0.7 and <italic>P</italic><sub>2.3.1.61 </sub>= 0.3 and, thus, to a correct annotation of O31550. By contrast, when annotating this protein with the univariate Bayesian approach, these probabilities are calculated independently (See Different strategies of annotation, Eq.(2)). <italic>P</italic><sub>2.3.1.12 </sub>falls to 0 because on the EC2.3.1.12 axis, around bit-score 231 (box to the right), we sample only proteins belonging to EC 2.3.1.61. In the same manner, for EC 2.3.1.61 around bit-score 225 (box on top), we observe only one protein out of 10 that truly belongs to EC 2.3.1.61 so that <italic>P</italic><sub>2.3.1.61 </sub>= 0.1. Hence, we wrongly assign O31550 to EC 2.3.1.61 but with a very low assignment probability <italic>P </italic>= 0.1.</p></sec><sec><title>Exploring the CI space for EC 1.6.5.3 (NADH dehydrogenase (ubiquinone)) and EC 1.6.99.5 (NADH dehydrogenase (quinone))</title><p>There is also strong sequence similarity between proteins from these two EC classes and there exists a quite well defined "boundary" that is densely populated (Fig. <xref ref-type="fig" rid="F3">3(b)</xref>). Very clearly the projections on the CI axes intrinsic to the univariate approach tend to mix the 804 proteins from the two EC classes leading to poor performances (at P = 1, r = 0.014 for 44.2% coverage) whereas the multivariate method can adapt to the boundary and leads to improved performances (at P = 1, r = 0.0028 for 90.0% coverage). These cases clearly exemplify that the projections on the CI axes can have great influence on the probability calculation and may result in annotation errors. It also shows that the multivariate method outperforms the univariate approach because of its ability to adapt to the shape of the boundary between functional classes in the CI space.</p></sec></sec><sec><title>Analysing the origins of annotation errors</title><p>The proposed Bayesian annotation strategies optimise the exploitation of the functional information carried by CIs built upon sequence similarity clues (BLAST bit-scores). We explore examples of the failure of these clues leading to annotation errors when using the multivariate Bayesian method.</p><sec><title>Annotation errors between Glyceraldehyde 3-phosphate dehydrogenases</title><p>Proteins from classes EC 1.2.1.12 and EC 1.2.1.59 catalyse the same reaction (Glyceraldehyde 3-phosphate dehydrogenation) but EC 1.2.1.12 proteins are NAD-dependent while EC 1.2.1.59 proteins can use both NAD and NADP as cofactors. As illustrated in Figure <xref ref-type="fig" rid="F3">3(c)</xref>, there exists strong cross-similarity between sequences from these two classes but each class tends to occupy a separate part of the CI space so that annotation can be done accurately. We note four exceptions: four proteins from EC 1.2.1.59 (black triangles; [Swiss-Prot:<ext-link ext-link-type="sprot" xlink:href="O09452">O09452</ext-link>, Swiss-Prot:<ext-link ext-link-type="sprot" xlink:href="O34425">O34425</ext-link>, Swiss-Prot:<ext-link ext-link-type="sprot" xlink:href="P80505">P80505</ext-link>, Swiss-Prot:<ext-link ext-link-type="sprot" xlink:href="Q48335">Q48335</ext-link>]) are closer to the EC 1.2.1.12 cloud than to the other EC 1.2.1.59 proteins in the CI space and thus are wrongly re-annotated as EC 1.2.1.12 proteins. The erroneously re-annotated EC 1.2.1.59 sequence O34425 is <italic>Bacillus subtilis </italic>gapB protein. Protein gapA [Swiss-Prot:<ext-link ext-link-type="sprot" xlink:href="P09124">P09124</ext-link>], also from <italic>B. subtilis </italic>belongs to class EC 1.2.1.12. It was shown that gapA can acquire the gapB activity with only two amino acids mutations (D32A and L187N) [<xref ref-type="bibr" rid="B24">24</xref>]; actually, gapB possesses these mutations. Therefore, a reasonable hypothesis is that gapA and gapB originate from a gene duplication event followed by divergent evolution. From the topology of Figure <xref ref-type="fig" rid="F3">3(c)</xref>, it is possible that similar scenarios apply to the three other "misplaced" EC 1.2.1.59 sequences. Here, functional specialisation can be achieved with only a few modifications at specific sites. General alignment tools like BLAST do not capture the higher significance of mutations at these sites compared to alterations at other sites; this leads to annotation errors difficult to avoid with automatic general-purpose tools.</p></sec><sec><title>Annotation errors between two-sector ATPases</title><p>Another interesting example of annotation errors comes from the classes EC 3.6.3.14 and EC 3.6.3.15, both of which contain transporting two-sector ATPases, the former transporting H<sup>+ </sup>and the latter Na<sup>+</sup>. In the CI space, the two clouds of points marking the proteins from these classes exactly overlap (data not shown) i.e. CIs based on BLAST bit-scores do not capture any sequence specificity distinguishing the two EC classes (the two classes are associated with the same 5 PROSITE patterns [<xref ref-type="bibr" rid="B25">25</xref>]). EC 3.6.3.15 being much less populated than EC 3.6.3.14 (16 members and 1252 members, respectively), this particular topology results in the 16 EC 3.6.3.15 sequences to be wrongly assigned to EC 3.6.3.14 with a high confidence (P = 1 in the 16 cases) because a large majority of their neighbours in the CI space belongs to EC 3.6.3.14. More generally, when CIs do not allow the distinction of two classes then we expect most sequences to be assigned to the larger class with an assignment probability equal to the relative size of this class. Hence, unless one class is greatly larger than the other one, assignment probabilities will be significantly smaller than 1 allowing us to filter out these specious annotations. In other words, the 16 erroneous annotations of EC 3.6.3.15 proteins originate from a class size effect. In most situations class sizes are of the same order and such a local topology of the CI space leads to easily detectable annotations errors (low assignment probabilities). This example of annotation errors actually explains how, by scanning the local configuration of the CI space, the Bayesian strategies can avoid a number of errors.</p></sec><sec><title>Example of annotation error propagation</title><p>In the present work, we considered the annotations associated to the sequences in the ENZYME database to be exact. Nevertheless, analysis of the origins of annotation errors using visual representations of the CI space as shown Figure <xref ref-type="fig" rid="F3">3</xref>, revealed peculiar configurations of the sequence-function relationship. A close investigation of these cases allowed us to identify three clear annotation errors. Figure <xref ref-type="fig" rid="F3">3(d)</xref> provides an example of error identification. Protein P94598 [Swiss-Prot:<ext-link ext-link-type="sprot" xlink:href="P94598">P94598</ext-link>] is annotated as a member of EC 1.4.1.3 (NAD(P)-utilizing glutamate dehydrogenase) but the multivariate Bayesian method assigned it to EC 1.4.1.4 (NADP-specific glutamate dehydrogenase) with an assignment probability of 1. Indeed, P94598 is close to a group of EC 1.4.1.4 proteins in the CI space. Tracing the source of this annotation, we noted that its strong CI value with EC1.4.1.4 originated from a strong sequence similarity with protein P95544 [Swiss-Prot:<ext-link ext-link-type="sprot" xlink:href="P95544">P95544</ext-link>] annotated as EC 1.4.1.4. By checking the publication associated with the annotation of P95544, we noted that this protein was wrongly annotated and actually belongs to EC 1.4.1.3 [<xref ref-type="bibr" rid="B26">26</xref>]. Correcting this database annotation error, the CI value of P94598 with EC 1.4.1.3 increases while its CI value with EC 1.4.1.4 decreases so that in fact the multivariate Bayesian method correctly classifies it to EC 1.4.1.3 (Fig. <xref ref-type="fig" rid="F3">3(d)</xref>). Interestingly, this example provides an illustration of an annotation error susceptible to propagate [<xref ref-type="bibr" rid="B20">20</xref>]. The correction of the annotation of P95544 was submitted to the ENZYME database and is expected to be included in future releases. Another example comes from P17692 [Swiss-Prot:<ext-link ext-link-type="sprot" xlink:href="P17692">P17692</ext-link>] that we classify as EC 2.4.1.19 (cyclomaltodextrin glucanotransferase) in disagreement with its database annotation: EC 3.2.1.1 (alpha-amylase). Actually, the EC 2.4.1.19 activity of P17692 has been described in the literature [<xref ref-type="bibr" rid="B27">27</xref>]. In addition, we found that Q11119 [Swiss-Prot:<ext-link ext-link-type="sprot" xlink:href="Q11119">Q11119</ext-link>] (EC 3.1.2.14, oleoyl-[acyl-carrier protein] hydrolase) should be annotated as EC 3.1.2.15 (ubiquitin thiolesterase). The experts of ENZYME have validated these two annotation errors and corrected the corresponding database entries.</p></sec></sec></sec><sec sec-type="discussion"><title>Discussion</title><p>The maintenance of various aspects of protein function is intricate due to the inhomogeneity of the sequence-function relationship. For example, 60% of EC classes with more than 2 members could not be perfectly discriminated by sequence similarity at any BLAST threshold [<xref ref-type="bibr" rid="B28">28</xref>]. Moreover, the 4 (or first 3) EC digits were systematically identical only above 80% (or 50%) sequence identity in structural alignments, while at the other end of the spectrum, the preservation of the 4 EC digits was observed at as low as 16% identity [<xref ref-type="bibr" rid="B29">29</xref>]. Consequently, the threshold below which sequence similarity should not be considered for annotation transfer at a given confidence level should in general be determined for each functional class independently. However, it is typically set in a uniform manner. In sharp contrast, the two Bayesian methods developed here take into account how functional classes are distributed locally in the relevant part of the CI space or along CI axes and assign a low probability where the sequence-function relationship is ambiguous.</p><p>Interestingly, with both Bayesian approaches, a large majority of proteins have been re-annotated with an assignment probability of 1 (Tables <xref ref-type="table" rid="T1">1</xref> and <xref ref-type="table" rid="T2">2</xref>). In the case of the multivariate Bayesian method, it means that for 96.0% of the enzymes of our dataset their 10 nearest enzymes in the CI space have the same EC number. Also, at the fourth level of the EC hierarchy, 255 classes out of 589 (43%) are isolated i.e. the 10553 proteins out of 28088 (38%) belonging to these classes have no BLAST hit (above threshold <italic>S</italic><sub>0 </sub>= 45) with the proteins of the other classes. This illustrates that there exists a high level of clustering of enzymes sharing their four EC digits in the CI and sequence spaces. Thus, for the filtered ENZYME database we considered in this analysis (enzymes catalysing one reaction only and EC categories with more than 11 members; see Methods), CI based on sequence similarity is a meaningful clue to predict the full EC code. In contrast, considering EC digit conservation based on pairwise sequence comparison, it was found that a good practical rule was to transfer 2 EC digits above 15% sequence identity [<xref ref-type="bibr" rid="B29">29</xref>]. There is no contradiction here. Essentially, when considering sufficiently populated EC classes, for most sequences we find very close homologues within their class allowing a clear functional annotation. This property of large EC classes also explains why the optimal CIs are obtained for &#x003b1;&#x02192;&#x0221e; (See Determining the optimal correspondence indicator) i.e. why the optimal CIs reduce to the best BLAST bit-score with each class while the number of hits is not taken into consideration (See Defining correspondence indicators): the important property in the sequence-EC class relationship is that the EC class contains at least one highly similar sequence to the query sequence under study. This situation also clarifies the reason for the good performance of the simple BLAST best-hit strategy for the tested data set (error rate smaller than 0.0045; Fig. <xref ref-type="fig" rid="F2">2</xref>). A priori, the well-specified clustering of sequences belonging to the same class cannot be generalised to other classifications of proteins, so depending on the sequence classification scheme under consideration it is important to measure the optimal &#x003b1; value. In situations where this value is small (i.e. when the number of hits is more significant than their scores), it is predictable that the difference between the performances of the Bayesian approaches and the simple BLAST best-hit method will be greatly increased.</p></sec><sec sec-type="conclusions"><title>Conclusion</title><p>The importance of standardising the systems by which biological functions are described is now generally recognised [<xref ref-type="bibr" rid="B30">30</xref>]. This has opened up the possibility for high-throughput automatic retrieval of sequences based on functional characteristics. In the present work, we demonstrate the great potential offered by a classification of protein functions to improve the quality of sequence annotations. Indeed, the availability of such a functional classification allows the definition of measures of correspondence between a sequence and all functional classes i.e. it permits taking advantage of the complete set of similarity relationships of a query sequence with the sequences from a reference database. The automated Bayesian methodologies provide reliable information about the sequences whose assignment probability is large enough (in this work, P = 1) leaving behind the more "difficult" cases. In an annotation pipeline, these methodologies could be an efficient filter to focus the work of human experts on the more error prone cases [<xref ref-type="bibr" rid="B31">31</xref>]. Along the same lines, inconsistencies between automated annotation and database annotation could be used to highlight possible annotation errors [<xref ref-type="bibr" rid="B32">32</xref>]; in this context, visual representations like those presented in Figure <xref ref-type="fig" rid="F3">3</xref> can be a useful tool for human experts.</p><p>An important aspect of this work is the construction of correspondence indicators between sequences and functional classes (Eq.(1)). Here, we used BLAST bit-scores for this process but the score from any pairwise protein comparison can be used instead e.g. structural comparison [<xref ref-type="bibr" rid="B33">33</xref>,<xref ref-type="bibr" rid="B34">34</xref>] or alignment-independent measures that can be computed from the primary sequence like length, word frequency, molecular weight or total charge [<xref ref-type="bibr" rid="B8">8</xref>,<xref ref-type="bibr" rid="B9">9</xref>,<xref ref-type="bibr" rid="B22">22</xref>]. Note that in principle, any measure of relationship between sequence and function can be used instead of CIs. In a previous study, it was shown that the simple BLAST best-hit approach outperformed three machine-learning methods based on alignment-independent features for the classification of enzymes within the EC hierarchy [<xref ref-type="bibr" rid="B22">22</xref>]. In contrast, the two Bayesian classifiers based on CIs outperform sequence similarity alone in term of sensitivity and specificity. This suggests that CIs could reveal themselves to be powerful features as input to machine-learning approaches for protein classification [<xref ref-type="bibr" rid="B21">21</xref>,<xref ref-type="bibr" rid="B23">23</xref>]. It remains to be seen whether the performance of CIs based on pairwise BLAST bit-scores is constant across various classification problems e.g. when there is only remote homology between class members [<xref ref-type="bibr" rid="B35">35</xref>].</p><p>The analytical development leading to CIs can be extended to construct a measure of correspondence between two functional classes that describes the degree of their overlap in the CI space (Fig. <xref ref-type="fig" rid="F3">3</xref>). Since a strong overlap indicates that two functional classes cannot be distinguished by the CIs, we can build an "adapted" functional classification by merging functional classes based on this new criterion. Interestingly, this amounts to empirically solve the problem of the extent of the functional annotation that can be transferred [<xref ref-type="bibr" rid="B29">29</xref>]. For example, EC 3.6.3.14 and EC 3.6.3.15 exactly overlap in the CI space (See Analysing the origins of annotation errors), this means that BLAST-based CIs simply do not differentiate these two types of transporting two-sector ATPases. It is more effective in an automated system to group these two classes in a Meta EC class "Na<sup>+ </sup>or H<sup>+ </sup>transporting two-sector ATPases" that we can reliably assign to. A key feature of the proposed methodologies is the quantification of the reliability of annotations; the assignment probability represents an attractive candidate, both versatile and compact, to qualify non-experimentally based annotations. In principle, it could be taken into account by the Bayesian annotation framework allowing its iterative usage without risking the propagation of annotation errors [<xref ref-type="bibr" rid="B20">20</xref>]. It is our hope that the Bayesian annotation strategies presented herein will contribute to more robust automatic annotation pipelines.</p></sec><sec sec-type="methods"><title>Methods</title><sec><title>A database of enzymes</title><p>In the present work, we put forward a method of classification of uncharacterised proteins, based on their pattern of homology with a reference set of classified proteins. We validate this approach on a database of enzymes annotated by their four-digit EC number. Annotations and sequences have been retrieved using release 30 of ENZYME [<xref ref-type="bibr" rid="B36">36</xref>]) and release 41 of SWISSPROT [<xref ref-type="bibr" rid="B37">37</xref>]. We quantified the homology relationship between two proteins by the bit-score of the alignment between their sequence using BLAST with default parameters settings [<xref ref-type="bibr" rid="B6">6</xref>]. Query sequences were masked for low-complexity regions using CAST [<xref ref-type="bibr" rid="B38">38</xref>]. Where BLAST reports more than one significant hit between two sequences, we retain only the best bit-score. We performed a BLAST "all against all" comparison between enzymes and stored all pairwise best bit-scores greater than 45 (E-value cut-off of 10<sup>-5 </sup>for the database under consideration).</p><p>The tree-like structure of the EC nomenclature [See <xref ref-type="supplementary-material" rid="S1">Additional file 1</xref>, Section S1] suggests that the EC classification defines a functional partition of enzymes. However, 1078 enzymes are classified into multiple EC classes. This can originate from overlaps in the definition of EC classes, or from multi-functional enzymes. In the present work, we do not take explicitly into account the possibility of multi-functional proteins. Hence, all enzymes with more than one EC number were discarded in order to obtain a reference dataset where the functional classification defines a partition of the protein sequence set. In addition, protein sequences annotated as "fragment" in SWISSPROT have not been considered. Ultimately, the probabilistic framework of annotation we developed requires a minimum number of proteins in each class for the functional assignments to be meaningful. We fixed this minimum number to 10 proteins and so ignored all classes containing less than 11 members (we re-annotate each enzyme using a leave-one-out method; see Validation by re-annotation). Finally, we removed the 215 sequences that did not present any hit in our database of local alignments. This defined the reference set of 28088 protein sequences used in the present analysis as well as their functional classification.</p></sec><sec><title>Validation by re-annotation</title><p>In order to quantify the performance of the different annotation strategies presented above, they were applied to re-annotate the filtered ENZYME database using a leave-one-out procedure. This method consists in removing in turn each enzyme from the reference dataset and to re-annotate it as if it was a new enzyme of unknown activity. The so-obtained classification of enzymes was then compared to the original classification. For the two Bayesian methods, new enzymes were assigned to the functional class for which the estimated probability is the highest.</p></sec></sec><sec><title>Authors' contributions</title><p>All authors participated in the design of the study and writing of the manuscript. EDL implemented the methodology and performed the analysis. All authors read and approved the final manuscript.</p></sec><sec sec-type="supplementary-material"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="S1"><caption><title>Additional File 1</title><p>contains a more detailed description of the EC nomenclature to complement section "A database of enzymes" and the full calculation leading to equations(2) and(3) along with a figure illustrating their meaning.</p></caption><media xlink:href="1471-2105-6-302-S1.pdf" mimetype="application" mime-subtype="pdf"><caption><p>Click here for file</p></caption></media></supplementary-material></sec></body><back><sec><title>Acknowledgements</title><p>We thank members of the Computational Genomics Group for comments, Kristian Axelsen for helpful exchanges, G. Akoun and S. Maslau for reading the manuscript. C.A.O. acknowledges additional support from IBM Research.</p></sec><ref-list><ref id="B1"><mixed-citation publication-type="journal"><name><surname>Janssen</surname><given-names>P</given-names></name><name><surname>Audit</surname><given-names>B</given-names></name><name><surname>Cases</surname><given-names>I</given-names></name><name><surname>Darzentas</surname><given-names>N</given-names></name><name><surname>Goldovsky</surname><given-names>L</given-names></name><name><surname>Kunin</surname><given-names>V</given-names></name><name><surname>Lopez-Bigas</surname><given-names>N</given-names></name><name><surname>Peregrin-Alvarez</surname><given-names>JM</given-names></name><name><surname>Pereira-Leal</surname><given-names>JB</given-names></name><name><surname>Tsoka</surname><given-names>S</given-names></name><name><surname>Ouzounis</surname><given-names>CA</given-names></name><article-title>Beyond 100 genomes</article-title><source>Genome Biol</source><year>2003</year><volume>6</volume><fpage>402</fpage><pub-id pub-id-type="doi">10.1186/gb-2003-4-5-402</pub-id><pub-id pub-id-type="pmid">12734008</pub-id></mixed-citation></ref><ref id="B2"><mixed-citation publication-type="journal"><name><surname>Andrade</surname><given-names>MA</given-names></name><name><surname>Sander</surname><given-names>C</given-names></name><article-title>Bioinformatics: from genome data to biological knowledge</article-title><source>Curr Opin Biotechnol</source><year>1997</year><volume>6</volume><fpage>675</fpage><lpage>683</lpage><pub-id pub-id-type="doi">10.1016/S0958-1669(97)80118-8</pub-id><pub-id pub-id-type="pmid">9425655</pub-id></mixed-citation></ref><ref id="B3"><mixed-citation publication-type="journal"><name><surname>Karp</surname><given-names>PD</given-names></name><article-title>What we do not know about sequence analysis and sequence databases</article-title><source>Bioinformatics</source><year>1998</year><volume>6</volume><fpage>753</fpage><lpage>754</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/14.9.753</pub-id><pub-id pub-id-type="pmid">10366280</pub-id></mixed-citation></ref><ref id="B4"><mixed-citation publication-type="journal"><name><surname>Pearson</surname><given-names>WR</given-names></name><article-title>Rapid and sensitive sequence comparison with FASTP and FASTA</article-title><source>Methods Enzymol</source><year>1990</year><volume>6</volume><fpage>63</fpage><lpage>98</lpage><pub-id pub-id-type="pmid">2156132</pub-id></mixed-citation></ref><ref id="B5"><mixed-citation publication-type="journal"><name><surname>Altschul</surname><given-names>SF</given-names></name><name><surname>Gish</surname><given-names>W</given-names></name><name><surname>Miller</surname><given-names>W</given-names></name><name><surname>Myers</surname><given-names>EW</given-names></name><name><surname>Lipman</surname><given-names>DJ</given-names></name><article-title>Basic local alignment search tool</article-title><source>J Mol Biol</source><year>1990</year><volume>6</volume><fpage>403</fpage><lpage>410</lpage><pub-id pub-id-type="doi">10.1006/jmbi.1990.9999</pub-id><pub-id pub-id-type="pmid">2231712</pub-id></mixed-citation></ref><ref id="B6"><mixed-citation publication-type="journal"><name><surname>Altschul</surname><given-names>SF</given-names></name><name><surname>Madden</surname><given-names>TL</given-names></name><name><surname>Schaffer</surname><given-names>AA</given-names></name><name><surname>Zhang</surname><given-names>J</given-names></name><name><surname>Zhang</surname><given-names>Z</given-names></name><name><surname>Miller</surname><given-names>W</given-names></name><name><surname>Lipman</surname><given-names>DJ</given-names></name><article-title>Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</article-title><source>Nucleic Acids Res</source><year>1997</year><volume>6</volume><fpage>3389</fpage><lpage>3402</lpage><pub-id pub-id-type="doi">10.1093/nar/25.17.3389</pub-id><pub-id pub-id-type="pmid">9254694</pub-id></mixed-citation></ref><ref id="B7"><mixed-citation publication-type="journal"><name><surname>Krogh</surname><given-names>A</given-names></name><name><surname>Brown</surname><given-names>M</given-names></name><name><surname>Mian</surname><given-names>IS</given-names></name><name><surname>Sjolander</surname><given-names>K</given-names></name><name><surname>Haussler</surname><given-names>D</given-names></name><article-title>Hidden Markov models in computational biology. Applications to protein modeling</article-title><source>J Mol Biol</source><year>1994</year><volume>6</volume><fpage>1501</fpage><lpage>1531</lpage><pub-id pub-id-type="doi">10.1006/jmbi.1994.1104</pub-id><pub-id pub-id-type="pmid">8107089</pub-id></mixed-citation></ref><ref id="B8"><mixed-citation publication-type="journal"><name><surname>Vinga</surname><given-names>S</given-names></name><name><surname>Almeida</surname><given-names>J</given-names></name><article-title>Alignment-free sequence comparison-a review</article-title><source>Bioinformatics</source><year>2003</year><volume>6</volume><fpage>513</fpage><lpage>523</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btg005</pub-id><pub-id pub-id-type="pmid">12611807</pub-id></mixed-citation></ref><ref id="B9"><mixed-citation publication-type="journal"><name><surname>Vries</surname><given-names>JK</given-names></name><name><surname>Munshi</surname><given-names>R</given-names></name><name><surname>Tobi</surname><given-names>D</given-names></name><name><surname>Klein-Seetharaman</surname><given-names>J</given-names></name><name><surname>Benos</surname><given-names>PV</given-names></name><name><surname>Bahar</surname><given-names>I</given-names></name><article-title>A sequence alignment-independent method for protein classification</article-title><source>Appl Bioinformatics</source><year>2004</year><volume>6</volume><fpage>137</fpage><lpage>148</lpage><pub-id pub-id-type="doi">10.2165/00822942-200403020-00008</pub-id><pub-id pub-id-type="pmid">15693739</pub-id></mixed-citation></ref><ref id="B10"><mixed-citation publication-type="journal"><name><surname>Abascal</surname><given-names>F</given-names></name><name><surname>Valencia</surname><given-names>A</given-names></name><article-title>Automatic annotation of protein function based on family identification</article-title><source>Proteins</source><year>2003</year><volume>6</volume><fpage>683</fpage><lpage>692</lpage><pub-id pub-id-type="doi">10.1002/prot.10449</pub-id><pub-id pub-id-type="pmid">14579359</pub-id></mixed-citation></ref><ref id="B11"><mixed-citation publication-type="journal"><name><surname>Krebs</surname><given-names>WG</given-names></name><name><surname>Bourne</surname><given-names>PE</given-names></name><article-title>Statistically rigorous automated protein annotation</article-title><source>Bioinformatics</source><year>2004</year><volume>6</volume><fpage>1066</fpage><lpage>1073</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/bth039</pub-id><pub-id pub-id-type="pmid">14764575</pub-id></mixed-citation></ref><ref id="B12"><mixed-citation publication-type="journal"><name><surname>Leontovich</surname><given-names>AM</given-names></name><name><surname>Brodsky</surname><given-names>LI</given-names></name><name><surname>Drachev</surname><given-names>VA</given-names></name><name><surname>Nikolaev</surname><given-names>VK</given-names></name><article-title>Adaptive algorithm of automated annotation</article-title><source>Bioinformatics</source><year>2002</year><volume>6</volume><fpage>838</fpage><lpage>844</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/18.6.838</pub-id><pub-id pub-id-type="pmid">12075019</pub-id></mixed-citation></ref><ref id="B13"><mixed-citation publication-type="journal"><name><surname>Tatusov</surname><given-names>RL</given-names></name><name><surname>Galperin</surname><given-names>MY</given-names></name><name><surname>Natale</surname><given-names>DA</given-names></name><name><surname>Koonin</surname><given-names>EV</given-names></name><article-title>The COG database: a tool for genome-scale analysis of protein functions and evolution</article-title><source>Nucleic Acids Res</source><year>2000</year><volume>6</volume><fpage>33</fpage><lpage>36</lpage><pub-id pub-id-type="doi">10.1093/nar/28.1.33</pub-id><pub-id pub-id-type="pmid">10592175</pub-id></mixed-citation></ref><ref id="B14"><mixed-citation publication-type="journal"><name><surname>Andrade</surname><given-names>MA</given-names></name><name><surname>Brown</surname><given-names>NP</given-names></name><name><surname>Leroy</surname><given-names>C</given-names></name><name><surname>Hoersch</surname><given-names>S</given-names></name><name><surname>de Daruvar</surname><given-names>A</given-names></name><name><surname>Reich</surname><given-names>C</given-names></name><name><surname>Franchini</surname><given-names>A</given-names></name><name><surname>Tamames</surname><given-names>J</given-names></name><name><surname>Valencia</surname><given-names>A</given-names></name><name><surname>Ouzounis</surname><given-names>C</given-names></name><name><surname>Sander</surname><given-names>C</given-names></name><article-title>Automated genome sequence analysis and annotation</article-title><source>Bioinformatics</source><year>1999</year><volume>6</volume><fpage>391</fpage><lpage>412</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/15.5.391</pub-id><pub-id pub-id-type="pmid">10366660</pub-id></mixed-citation></ref><ref id="B15"><mixed-citation publication-type="journal"><name><surname>Wilson</surname><given-names>CA</given-names></name><name><surname>Kreychman</surname><given-names>J</given-names></name><name><surname>Gerstein</surname><given-names>M</given-names></name><article-title>Assessing annotation transfer for genomics: quantifying the relations between protein sequence, structure and function through traditional and probabilistic scores</article-title><source>J Mol Biol</source><year>2000</year><volume>6</volume><fpage>233</fpage><lpage>249</lpage><pub-id pub-id-type="doi">10.1006/jmbi.2000.3550</pub-id><pub-id pub-id-type="pmid">10704319</pub-id></mixed-citation></ref><ref id="B16"><mixed-citation publication-type="journal"><name><surname>Kyrpides</surname><given-names>NC</given-names></name><name><surname>Ouzounis</surname><given-names>CA</given-names></name><article-title>Whole-genome sequence annotation: 'Going wrong with confidence'</article-title><source>Mol Microbiol</source><year>1999</year><volume>6</volume><fpage>886</fpage><lpage>887</lpage><pub-id pub-id-type="doi">10.1046/j.1365-2958.1999.01380.x</pub-id><pub-id pub-id-type="pmid">10361291</pub-id></mixed-citation></ref><ref id="B17"><mixed-citation publication-type="journal"><name><surname>Bork</surname><given-names>P</given-names></name><name><surname>Koonin</surname><given-names>EV</given-names></name><article-title>Predicting functions from protein sequences--where are the bottlenecks?</article-title><source>Nat Genet</source><year>1998</year><volume>6</volume><fpage>313</fpage><lpage>318</lpage><pub-id pub-id-type="doi">10.1038/ng0498-313</pub-id><pub-id pub-id-type="pmid">9537411</pub-id></mixed-citation></ref><ref id="B18"><mixed-citation publication-type="journal"><name><surname>Devos</surname><given-names>D</given-names></name><name><surname>Valencia</surname><given-names>A</given-names></name><article-title>Intrinsic errors in genome annotation</article-title><source>Trends Genet</source><year>2001</year><volume>6</volume><fpage>429</fpage><lpage>431</lpage><pub-id pub-id-type="doi">10.1016/S0168-9525(01)02348-4</pub-id><pub-id pub-id-type="pmid">11485799</pub-id></mixed-citation></ref><ref id="B19"><mixed-citation publication-type="journal"><name><surname>Gerlt</surname><given-names>JA</given-names></name><name><surname>Babbitt</surname><given-names>PC</given-names></name><article-title>Can sequence determine function?</article-title><source>Genome Biol</source><year>2000</year><volume>6</volume><fpage>REVIEWS0005</fpage><pub-id pub-id-type="doi">10.1186/gb-2000-1-5-reviews0005</pub-id><pub-id pub-id-type="pmid">11178260</pub-id></mixed-citation></ref><ref id="B20"><mixed-citation publication-type="journal"><name><surname>Gilks</surname><given-names>WR</given-names></name><name><surname>Audit</surname><given-names>B</given-names></name><name><surname>De Angelis</surname><given-names>D</given-names></name><name><surname>Tsoka</surname><given-names>S</given-names></name><name><surname>Ouzounis</surname><given-names>CA</given-names></name><article-title>Modeling the percolation of annotation errors in a database of protein sequences</article-title><source>Bioinformatics</source><year>2002</year><volume>6</volume><fpage>1641</fpage><lpage>1649</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/18.12.1641</pub-id><pub-id pub-id-type="pmid">12490449</pub-id></mixed-citation></ref><ref id="B21"><mixed-citation publication-type="journal"><name><surname>Cheng</surname><given-names>BY</given-names></name><name><surname>Carbonell</surname><given-names>JG</given-names></name><name><surname>Klein-Seetharaman</surname><given-names>J</given-names></name><article-title>Protein classification based on text document classification techniques</article-title><source>Proteins</source><year>2005</year><volume>6</volume><fpage>955</fpage><lpage>970</lpage><pub-id pub-id-type="doi">10.1002/prot.20373</pub-id><pub-id pub-id-type="pmid">15645499</pub-id></mixed-citation></ref><ref id="B22"><mixed-citation publication-type="journal"><name><surname>des Jardins</surname><given-names>M</given-names></name><name><surname>Karp</surname><given-names>PD</given-names></name><name><surname>Krummenacker</surname><given-names>M</given-names></name><name><surname>Lee</surname><given-names>TJ</given-names></name><name><surname>Ouzounis</surname><given-names>CA</given-names></name><article-title>Prediction of enzyme classification from protein sequence without the use of sequence similarity</article-title><source>Proc Int Conf Intell Syst Mol Biol</source><year>1997</year><volume>6</volume><fpage>92</fpage><lpage>99</lpage><pub-id pub-id-type="pmid">9322021</pub-id></mixed-citation></ref><ref id="B23"><mixed-citation publication-type="journal"><name><surname>Karchin</surname><given-names>R</given-names></name><name><surname>Karplus</surname><given-names>K</given-names></name><name><surname>Haussler</surname><given-names>D</given-names></name><article-title>Classifying G-protein coupled receptors with support vector machines</article-title><source>Bioinformatics</source><year>2002</year><volume>6</volume><fpage>147</fpage><lpage>159</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/18.1.147</pub-id><pub-id pub-id-type="pmid">11836223</pub-id></mixed-citation></ref><ref id="B24"><mixed-citation publication-type="journal"><name><surname>Fillinger</surname><given-names>S</given-names></name><name><surname>Boschi-Muller</surname><given-names>S</given-names></name><name><surname>Azza</surname><given-names>S</given-names></name><name><surname>Dervyn</surname><given-names>E</given-names></name><name><surname>Branlant</surname><given-names>G</given-names></name><name><surname>Aymerich</surname><given-names>S</given-names></name><article-title>Two glyceraldehyde-3-phosphate dehydrogenases with opposite physiological roles in a nonphotosynthetic bacterium</article-title><source>J Biol Chem</source><year>2000</year><volume>6</volume><fpage>14031</fpage><lpage>14037</lpage><pub-id pub-id-type="doi">10.1074/jbc.275.19.14031</pub-id><pub-id pub-id-type="pmid">10799476</pub-id></mixed-citation></ref><ref id="B25"><mixed-citation publication-type="journal"><name><surname>Sigrist</surname><given-names>CJ</given-names></name><name><surname>Cerutti</surname><given-names>L</given-names></name><name><surname>Hulo</surname><given-names>N</given-names></name><name><surname>Gattiker</surname><given-names>A</given-names></name><name><surname>Falquet</surname><given-names>L</given-names></name><name><surname>Pagni</surname><given-names>M</given-names></name><name><surname>Bairoch</surname><given-names>A</given-names></name><name><surname>Bucher</surname><given-names>P</given-names></name><article-title>PROSITE: a documented database using patterns and profiles as motif descriptors</article-title><source>Brief Bioinform</source><year>2002</year><volume>6</volume><fpage>265</fpage><lpage>274</lpage><pub-id pub-id-type="doi">10.1093/bib/3.3.265</pub-id><pub-id pub-id-type="pmid">12230035</pub-id></mixed-citation></ref><ref id="B26"><mixed-citation publication-type="journal"><name><surname>Wen</surname><given-names>Z</given-names></name><name><surname>Morrison</surname><given-names>M</given-names></name><article-title>The NAD(P)H-dependent glutamate dehydrogenase activities of Prevotella ruminicola B(1)4 can be attributed to one enzyme (GdhA), and gdhA expression is regulated in response to the nitrogen source available for growth</article-title><source>Appl Environ Microbiol</source><year>1996</year><volume>6</volume><fpage>3826</fpage><lpage>3833</lpage><pub-id pub-id-type="pmid">8837439</pub-id></mixed-citation></ref><ref id="B27"><mixed-citation publication-type="journal"><name><surname>Itkor</surname><given-names>P</given-names></name><name><surname>Tsukagoshi</surname><given-names>N</given-names></name><name><surname>Udaka</surname><given-names>S</given-names></name><article-title>Nucleotide sequence of the raw-starch-digesting amylase gene from Bacillus sp. B1018 and its strong homology to the cyclodextrin glucanotransferase genes</article-title><source>Biochem Biophys Res Commun</source><year>1990</year><volume>6</volume><fpage>630</fpage><lpage>636</lpage><pub-id pub-id-type="doi">10.1016/0006-291X(90)90855-H</pub-id><pub-id pub-id-type="pmid">1689153</pub-id></mixed-citation></ref><ref id="B28"><mixed-citation publication-type="journal"><name><surname>Shah</surname><given-names>I</given-names></name><name><surname>Hunter</surname><given-names>L</given-names></name><article-title>Predicting enzyme function from sequence: a systematic appraisal</article-title><source>Proc Int Conf Intell Syst Mol Biol</source><year>1997</year><volume>6</volume><fpage>276</fpage><lpage>283</lpage><pub-id pub-id-type="pmid">9322050</pub-id></mixed-citation></ref><ref id="B29"><mixed-citation publication-type="journal"><name><surname>Devos</surname><given-names>D</given-names></name><name><surname>Valencia</surname><given-names>A</given-names></name><article-title>Practical limits of function prediction</article-title><source>Proteins</source><year>2000</year><volume>6</volume><fpage>98</fpage><lpage>107</lpage><pub-id pub-id-type="doi">10.1002/1097-0134(20001001)41:1&#x0003c;98::AID-PROT120&#x0003e;3.0.CO;2-S</pub-id><pub-id pub-id-type="pmid">10944397</pub-id></mixed-citation></ref><ref id="B30"><mixed-citation publication-type="journal"><name><surname>Ashburner</surname><given-names>M</given-names></name><name><surname>Ball</surname><given-names>CA</given-names></name><name><surname>Blake</surname><given-names>JA</given-names></name><name><surname>Botstein</surname><given-names>D</given-names></name><name><surname>Butler</surname><given-names>H</given-names></name><name><surname>Cherry</surname><given-names>JM</given-names></name><name><surname>Davis</surname><given-names>AP</given-names></name><name><surname>Dolinski</surname><given-names>K</given-names></name><name><surname>Dwight</surname><given-names>SS</given-names></name><name><surname>Eppig</surname><given-names>JT</given-names></name><name><surname>Harris</surname><given-names>MA</given-names></name><name><surname>Hill</surname><given-names>DP</given-names></name><name><surname>Issel-Tarver</surname><given-names>L</given-names></name><name><surname>Kasarskis</surname><given-names>A</given-names></name><name><surname>Lewis</surname><given-names>S</given-names></name><name><surname>Matese</surname><given-names>JC</given-names></name><name><surname>Richardson</surname><given-names>JE</given-names></name><name><surname>Ringwald</surname><given-names>M</given-names></name><name><surname>Rubin</surname><given-names>GM</given-names></name><name><surname>Sherlock</surname><given-names>G</given-names></name><article-title>Gene ontology: tool for the unification of biology.</article-title><source>Nat Genet</source><year>2000</year><volume>6</volume><fpage>25</fpage><lpage>29</lpage><pub-id pub-id-type="doi">10.1038/75556</pub-id><pub-id pub-id-type="pmid">10802651</pub-id></mixed-citation></ref><ref id="B31"><mixed-citation publication-type="journal"><name><surname>Gattiker</surname><given-names>A</given-names></name><name><surname>Michoud</surname><given-names>K</given-names></name><name><surname>Rivoire</surname><given-names>C</given-names></name><name><surname>Auchincloss</surname><given-names>AH</given-names></name><name><surname>Coudert</surname><given-names>E</given-names></name><name><surname>Lima</surname><given-names>T</given-names></name><name><surname>Kersey</surname><given-names>P</given-names></name><name><surname>Pagni</surname><given-names>M</given-names></name><name><surname>Sigrist</surname><given-names>CJ</given-names></name><name><surname>Lachaize</surname><given-names>C</given-names></name><name><surname>Veuthey</surname><given-names>AL</given-names></name><name><surname>Gasteiger</surname><given-names>E</given-names></name><name><surname>Bairoch</surname><given-names>A</given-names></name><article-title>Automated annotation of microbial proteomes in SWISS-PROT</article-title><source>Comput Biol Chem</source><year>2003</year><volume>6</volume><fpage>49</fpage><lpage>58</lpage><pub-id pub-id-type="doi">10.1016/S1476-9271(02)00094-4</pub-id><pub-id pub-id-type="pmid">12798039</pub-id></mixed-citation></ref><ref id="B32"><mixed-citation publication-type="journal"><name><surname>Wieser</surname><given-names>D</given-names></name><name><surname>Kretschmann</surname><given-names>E</given-names></name><name><surname>Apweiler</surname><given-names>R</given-names></name><article-title>Filtering erroneous protein annotation</article-title><source>Bioinformatics</source><year>2004</year><volume>6</volume><fpage>I342</fpage><lpage>I347</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/bth938</pub-id><pub-id pub-id-type="pmid">15262818</pub-id></mixed-citation></ref><ref id="B33"><mixed-citation publication-type="journal"><name><surname>Murzin</surname><given-names>AG</given-names></name><name><surname>Brenner</surname><given-names>SE</given-names></name><name><surname>Hubbard</surname><given-names>T</given-names></name><name><surname>Chothia</surname><given-names>C</given-names></name><article-title>SCOP: a structural classification of proteins database for the investigation of sequences and structures</article-title><source>J Mol Biol</source><year>1995</year><volume>6</volume><fpage>536</fpage><lpage>540</lpage><pub-id pub-id-type="doi">10.1006/jmbi.1995.0159</pub-id><pub-id pub-id-type="pmid">7723011</pub-id></mixed-citation></ref><ref id="B34"><mixed-citation publication-type="journal"><name><surname>Holm</surname><given-names>L</given-names></name><name><surname>Sander</surname><given-names>C</given-names></name><article-title>Mapping the protein universe</article-title><source>Science</source><year>1996</year><volume>6</volume><fpage>595</fpage><lpage>603</lpage><pub-id pub-id-type="pmid">8662544</pub-id></mixed-citation></ref><ref id="B35"><mixed-citation publication-type="journal"><name><surname>Jaakkola</surname><given-names>T</given-names></name><name><surname>Diekhans</surname><given-names>M</given-names></name><name><surname>Haussler</surname><given-names>D</given-names></name><article-title>A discriminative framework for detecting remote protein homologies</article-title><source>J Comput Biol</source><year>2000</year><volume>6</volume><fpage>95</fpage><lpage>114</lpage><pub-id pub-id-type="doi">10.1089/10665270050081405</pub-id><pub-id pub-id-type="pmid">10890390</pub-id></mixed-citation></ref><ref id="B36"><mixed-citation publication-type="journal"><name><surname>Bairoch</surname><given-names>A</given-names></name><article-title>The ENZYME database in 2000</article-title><source>Nucleic Acids Res</source><year>2000</year><volume>6</volume><fpage>304</fpage><lpage>305</lpage><pub-id pub-id-type="doi">10.1093/nar/28.1.304</pub-id><pub-id pub-id-type="pmid">10592255</pub-id></mixed-citation></ref><ref id="B37"><mixed-citation publication-type="journal"><name><surname>Boeckmann</surname><given-names>B</given-names></name><name><surname>Bairoch</surname><given-names>A</given-names></name><name><surname>Apweiler</surname><given-names>R</given-names></name><name><surname>Blatter</surname><given-names>MC</given-names></name><name><surname>Estreicher</surname><given-names>A</given-names></name><name><surname>Gasteiger</surname><given-names>E</given-names></name><name><surname>Martin</surname><given-names>MJ</given-names></name><name><surname>Michoud</surname><given-names>K</given-names></name><name><surname>O'Donovan</surname><given-names>C</given-names></name><name><surname>Phan</surname><given-names>I</given-names></name><name><surname>Pilbout</surname><given-names>S</given-names></name><name><surname>Schneider</surname><given-names>M</given-names></name><article-title>The SWISS-PROT protein knowledgebase and its supplement TrEMBL in 2003</article-title><source>Nucleic Acids Res</source><year>2003</year><volume>6</volume><fpage>365</fpage><lpage>370</lpage><pub-id pub-id-type="doi">10.1093/nar/gkg095</pub-id><pub-id pub-id-type="pmid">12520024</pub-id></mixed-citation></ref><ref id="B38"><mixed-citation publication-type="journal"><name><surname>Promponas</surname><given-names>VJ</given-names></name><name><surname>Enright</surname><given-names>AJ</given-names></name><name><surname>Tsoka</surname><given-names>S</given-names></name><name><surname>Kreil</surname><given-names>DP</given-names></name><name><surname>Leroy</surname><given-names>C</given-names></name><name><surname>Hamodrakas</surname><given-names>S</given-names></name><name><surname>Sander</surname><given-names>C</given-names></name><name><surname>Ouzounis</surname><given-names>CA</given-names></name><article-title>CAST: an iterative algorithm for the complexity analysis of sequence tracts. Complexity analysis of sequence tracts</article-title><source>Bioinformatics</source><year>2000</year><volume>6</volume><fpage>915</fpage><lpage>922</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/16.10.915</pub-id><pub-id pub-id-type="pmid">11120681</pub-id></mixed-citation></ref></ref-list></back></article>